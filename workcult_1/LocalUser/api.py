from rest_framework import generics, permissions, viewsets, status, mixins
from rest_framework.response import Response

from requests.exceptions import HTTPError
# The following import and then adding it to authentication classes is very important. Without this:
# the error was Authentication credentials were not provided.
# Took 24 hours to figure this out
from django.contrib.auth import login
from rest_framework.exceptions import PermissionDenied
from knox.auth import TokenAuthentication
from knox.models import AuthToken
from .models import LocalUser, GmailAccount, UserProfile, Company

from .serializers import (
                        UserSerializer,
                          RegisterSerializer,
                          LoginSerializer,

                        UserProfileSerializer,

                        # ForgotPasswordSerializer,
                        CompanySerializer
                          )


# Register API
class RegisterAPI(generics.GenericAPIView):
    serializer_class = RegisterSerializer

    # authentication_classes = (
    #     TokenAuthentication,
    # )

    # def get_serializer_context(self):
    #
    #     # print("FROM SERIALIZER CONTEXT = " + pprint(vars(self.request)))
    #     return {'request': self.request}

    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)

        serializer.is_valid(raise_exception=True)

        # HERE the user object returned is actually of LocalUser type only
        # because we initialized the model to LOCALUSER in serializers.py
        user = serializer.save()

        fortoken = LocalUser.objects.get(profile_id=user)

        # # send_mail(subject, message, from_email, to_list, fail_silently=True)
        #
        # subject = "Welcome to FootBuys!!"
        # message = "Hi " + user.first_name + ", \nThank you for registering with us. Glad to have you with us.\n\n\n\n\n\n\n\n This is an autogenerated email. Please do not try to revert back"
        # from_mail = settings.EMAIL_HOST_USER
        # to_list = [fortoken.email, settings.EMAIL_HOST_USER]
        #
        # send_mail(subject, message, from_mail, to_list, fail_silently=True)

        return Response({
            "user": UserProfileSerializer(user, context=self.get_serializer_context()).data,

            # In the video it was :
            #     "token": AuthToken.objects.create(user)
            # which gave an error.
            # Answer-
            # The Token.objects.create returns a tuple (instance, token). So in order to get token use the index 1
            # "token": AuthToken.objects.create(user)[1]

            "token": AuthToken.objects.create(fortoken)[1]
        })


# Login API
class LoginAPI(generics.GenericAPIView):
    # login_url = 'api/auth/login/'
    print("BEFORE SERIALIZER CLASS")
    permission_classes = [
        # permissions.IsAuthenticated,
    ]

    # authentication_classes = (
    #     TokenAuthentication,
    # )

    serializer_class = LoginSerializer

    def post(self, request, *args, **kwargs):
        print("REQUEST.DATA = " + str(request.data))
        serializer = self.get_serializer(data=request.data)
        # serializer = self.serializer_class(data=request.data, context={'request': request})
        print("BEFORE IS_VALID IS CALLED! ")
        serializer.is_valid(raise_exception=True)

        print(str(serializer))

        # was written as
        # user = serializer.validate_data
        # which gave an error
        user = serializer.validated_data
        userprofile = UserProfile.objects.get(localuser=user)
        # login(request, user)
        return Response({
            "user": UserProfileSerializer(userprofile, context=self.get_serializer_context()).data,
            # "token": AuthToken.objects.create(user)[1]
            "token": AuthToken.objects.create(user=user)[1],
            # "token": serializer.serialize('json', AuthToken.objects.create(user=user))
            # "mytoken": AuthToken.objects.create(user=user)
        })


# Get User API
# class UserAPI(
#                 viewsets.GenericViewSet,
#                 viewsets.mixins.ListModelMixin,
#                 viewsets.mixins.RetrieveModelMixin,
#                 viewsets.mixins.DestroyModelMixin):

class UserAPI(generics.RetrieveAPIView):

    permission_classes = [

        permissions.IsAuthenticated,
        # permissions.AllowAny,
    ]

    authentication_classes = (
        TokenAuthentication,
    )

    queryset = UserProfile.objects.all()

    serializer_class = UserProfileSerializer

    def get_queryset(self):
        return UserProfile.objects.filter(localuser=self.request.user)

    def get_object(self):
        return UserProfile.objects.get(localuser=self.request.user)



class UserViewSet(viewsets.ModelViewSet):
    queryset = LocalUser.objects.all()
    serializer_class = UserSerializer

    authentication_classes = (
        TokenAuthentication,
    )

    # print(permissions.IsAuthenticated)

    def retrieve(self, request, pk=None):
        print("User is "+self.request.user)


class CompanyAPIView(
                    viewsets.GenericViewSet,
                    viewsets.mixins.ListModelMixin,
                    viewsets.mixins.UpdateModelMixin,
                    viewsets.mixins.RetrieveModelMixin,
                    viewsets.mixins.DestroyModelMixin):

    serializer_class = CompanySerializer

    queryset = Company.objects.all()

    def get_queryset(self):
        return Company.objects.all()

    def create(self, request, *args, **kwargs):
        print("INSIDE CREATE!! ")
        serializer = self.get_serializer(data=request.data)
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        # if we would have used CreateModelMixin,
        # then we would not have been able to check
        # the following condition:
        # if request.data['user'] != str(request.user.profile_id.id):
        #     raise PermissionDenied("You cannot make bookmarks for other people!")
        if not request.user.is_admin:
            raise PermissionDenied("You cannot create company if you are not admin")
        serializer.save()
        return Response(serializer.data, status=status.HTTP_202_ACCEPTED)

